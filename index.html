<html>
  <head>
    <title>My first three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/cannon.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/STLLoader.js"></script>
    <script src="js/duplo.js"></script>
    <script>
      const SETTINGS = {
        world: {x:10, y:5, z:10},
        //block: {x:3.2, y:2, z:3.2},
        //sphere: {r:1.4}
        //block: {x:31.7, y:42.75/2, z:31.7},
        block: {x:31.5, y:38/2, z:31.5},
        sphere: {r:14}
      };

      let scene = new THREE.Scene();
      let camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 0.1, 1000 );

      let renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setClearColor(0xccffaa);
      document.body.appendChild( renderer.domElement );

      let grid = new Grid(SETTINGS);
      scene.add(grid.getMesh());

      let cursor = new Cursor(grid, SETTINGS);
      grid.getMesh().add(cursor.getMesh());

      let directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(-1, 0.8, 0.6);
      scene.add(directionalLight);

      directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, -0.8, -0.6);
      scene.add(directionalLight);

      let ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const scale = 1.1;
      camera.position.set(
        0,//SETTINGS.block.x * SETTINGS.world.x * 0.3 * scale,
        SETTINGS.block.y * SETTINGS.world.y * 2 * scale,
        SETTINGS.block.z * SETTINGS.world.z * scale
      );

      let ball = new THREE.Mesh(
        new THREE.SphereGeometry(10, 32, 32),
        new THREE.MeshPhongMaterial({color:0xffffff})
      );
      grid.getMesh().add(ball);
      let ballBody;
      let world = new CANNON.World();
      world.defaultContactMaterial.friction = 0.0;
      world.defaultContactMaterial.restitution = 0.0;
      world.gravity.set(0, -9.82, 0);
      world.broadphase = new CANNON.NaiveBroadphase();

      let sphereInterval = SETTINGS.block.x * 10 / 40;
      for (let x = 0; x < 20; x++) {
        for (let z = 0; z < 20; z++) {
          let sphereShape = new CANNON.Sphere(5);
          let sphereBody = new CANNON.Body({
            mass:0,
            shape:sphereShape,
            position:new CANNON.Vec3(
              (2 * x + 1) * sphereInterval,
              0,
              (2 * z + 1) * sphereInterval
            )
          });
          world.add(sphereBody);
          /*
          let sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(5));
          sphereMesh.position.copy(sphereBody.position);
          grid.getMesh().add(sphereMesh);
          */
        }
      }
      let isSimulating = false;
      let render = function () {
        requestAnimationFrame( render );
        renderer.render(scene, camera);
        if (isSimulating) {
          world.step(2 / 60.0);
          ball.position.copy(ballBody.position);
        }
      };

      const controls = new THREE.OrbitControls( camera, renderer.domElement );
      controls.addEventListener( 'change', render ); // remove when using animation loop
      controls.enableZoom = false;
      controls.enableKeys = false;
      //restrictControls(controls);

      cursor.getMesh().material.visible = false;
      grid.getMesh().material.visible = false;
      Block.loadModels(() => {
        cursor.getMesh().material.visible = true;
        grid.getMesh().material.visible = true;
        for (let x = 0; x < 4; x++) {
          for (let z = 0; z < 4; z++) {
            let mesh = Block.getGroundMesh();
            mesh.position.x = grid.settings.block.x * (x + 0.5) * 2.5;
            mesh.position.y = -grid.settings.block.y * 0.2;
            mesh.position.z = grid.settings.block.z * (z + 0.5) * 2.5;

            grid.getMesh().add(mesh);
          }
        }
      });

      render();

      function restrictControls(controls) {
        controls.minPolarAngle = Math.PI / 5;
        controls.maxPolarAngle = Math.PI / 5 * 2;
        controls.minAzimuthAngle = -Math.PI / 6;
        controls.maxAzimuthAngle = Math.PI / 6;
        controls.rotateSpeed = 0.7;
      }

      function freeControls(controls) {
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.minAzimuthAngle = -Infinity;
        controls.maxAzimuthAngle = Infinity;
        controls.rotateSpeed = 1.0;
      }

      function mouseMove(x, y) {
        let mouseDown = new MouseEvent("mousedown", {
          bubbles: true,
          cancelable: true,
          view: window,
          shiftKey: true
        });
        let mouseMove = new MouseEvent("mousemove", {
          bubbles: true,
          cancelable: true,
          view: window,
          shiftKey: true,
          clientX: x, 
          clientY: y
        });
        let mouseUp = new MouseEvent("mouseup", {
          bubbles: true,
          cancelable: true,
          view: window,
          shiftKey: true
        });
        controls.domElement.dispatchEvent(mouseDown);
        controls.domElement.dispatchEvent(mouseMove);
        controls.domElement.dispatchEvent(mouseUp);
      }

      document.addEventListener('keyup', (event) =>{
        if (event.key === ' ') {
          if (cursor.started) {
            cursor.stop();
          }
          else {
            cursor.start();
          }
        }
        else if (event.key === 'Enter') {
          cursor.complete();
          freeControls(controls);
          cursor.setupBody(world);
          ballBody = cursor.simulateBall(world);
          isSimulating = true;
        }
        else if (event.key === 'ArrowUp') {
          if (event.shiftKey) {
            mouseMove(0, 10);
          }
          else {
            cursor.moveBack();
          }
        }
        else if (event.key === 'ArrowDown') {
          if (event.shiftKey) {
            mouseMove(0, -10);
          }
          else {
            cursor.moveFront();
          }
        }
        else if (event.key === 'ArrowLeft') {
          if (event.shiftKey) {
            mouseMove(10, 0);
          }
          else {
            cursor.moveLeft();
          }
        }
        else if (event.key === 'ArrowRight') {
          if (event.shiftKey) {
            mouseMove(-10, 0);
          }
          else {
            cursor.moveRight();
          }
        }
        else if (event.key === 'a') {
          cursor.moveTop();
        }
        else if (event.key === 'z') {
          cursor.moveBottom();
        }
        else if (event.key === 's') {
          console.log(grid.getSummary());
        }
        else if (event.key === 'r') {
          cursor.reset();
          restrictControls(controls);
        }
        else if (event.key.match(/^\d$/)) {
          grid.showLayers(parseInt(event.key, 10));
        }
      });

/*
      var controllers = {};
      function gamepadHandler(event, connecting) {
        var gamepad = event.gamepad;
        console.log(gamepad);
        if (connecting) {
          controllers[gamepad.index] = gamepad;
        }
        else {
          delete controllers[gamepad.index];
        }
      }
      window.addEventListener("gamepadconnected", function(e) {
        gamepadHandler(e, true);
      });
      window.addEventListener("gamepaddisconnected", function(e) {
        gamepadHandler(e, false);
      });
      function scanGamepad() {
        var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
        for (var i = 0; i < gamepads.length; i++) {
          if (gamepads[i]) {
            controllers[gamepads[i].index] = gamepads[i];
          }
        }
      }
      function checkGamepad() {
        scanGamepad();
        for (i in controllers) {
          var gamepad = controllers[i];
          var buttonVals = gamepad.buttons.map((o) => o.pressed);
          //console.log(buttonVals);
        }
        window.requestAnimationFrame(checkGamepad);
      }
      checkGamepad();
*/
    </script>
  </body>
</html>
